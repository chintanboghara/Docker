# Docker Containers

A **Docker container** is a lightweight, standalone, and executable package that includes everything needed to run a piece of software—code, runtime, libraries, environment variables, and configuration files. Containers are instances of Docker images that run in isolated environments. Unlike traditional virtual machines, containers share the host operating system's kernel, making them more efficient and portable.

In Docker, **containers** provide an isolated environment for applications, ensuring that they run the same way across different systems. When you create a Docker container, it uses a Docker image as its base, and you can start, stop, or interact with it using Docker commands.

---

### Key Characteristics of Docker Containers

1. **Isolation**: Containers run in isolated environments. Each container has its own file system, network, and process space, separate from other containers and the host system.
   
2. **Lightweight**: Containers are lightweight because they share the host OS kernel rather than running a separate OS, unlike virtual machines. This makes containers faster to start and more efficient in resource usage.

3. **Ephemeral**: Containers are designed to be short-lived and disposable. Once a container stops, it can be removed. However, you can use Docker volumes to persist data across container restarts.

4. **Portability**: Containers encapsulate all dependencies and configurations, ensuring that applications will run the same on any system that has Docker installed. This is crucial for consistency across development, testing, and production environments.

---

### Docker Container Lifecycle

The lifecycle of a Docker container generally includes the following stages:

1. **Creating a Container**: When you run a container, Docker creates a container instance from a specified image.
   
2. **Running the Container**: Once created, the container starts running the application specified in the image (such as a web server or database).
   
3. **Stopping the Container**: A running container can be stopped, which halts its processes without deleting it.
   
4. **Removing the Container**: After a container is stopped, you can remove it, deleting the container and freeing up resources.

---

### Working with Docker Containers

#### 1. **Creating and Running a Container**

To create and run a container from a Docker image, use the `docker run` command:

```bash
docker run -d -p 8080:80 --name mycontainer nginx
```

- `-d`: Runs the container in detached mode (in the background).
- `-p 8080:80`: Maps port 8080 on the host to port 80 inside the container.
- `--name mycontainer`: Assigns a name to the container (optional).
- `nginx`: Specifies the image to use (in this case, the official Nginx image).

This command will:
1. Download the `nginx` image from Docker Hub (if it’s not already present).
2. Create and start a new container named `mycontainer` from the `nginx` image.
3. Expose port 80 inside the container and map it to port 8080 on the host system.

You can now access the Nginx web server in your browser by navigating to `http://localhost:8080`.

#### 2. **Listing Running Containers**

To list the currently running containers, use:

```bash
docker ps
```

This command will display information about the running containers, such as container ID, image, status, and ports.

If you want to list all containers, including stopped ones, use:

```bash
docker ps -a
```

#### 3. **Stopping a Container**

To stop a running container, use the `docker stop` command followed by the container name or ID:

```bash
docker stop mycontainer
```

This will stop the container named `mycontainer` gracefully.

#### 4. **Removing a Container**

To remove a stopped container, use the `docker rm` command:

```bash
docker rm mycontainer
```

This will remove the container named `mycontainer`. Note that a container must be stopped before it can be removed.

#### 5. **Starting a Stopped Container**

You can start a previously stopped container using:

```bash
docker start mycontainer
```

#### 6. **Accessing a Running Container**

To access a running container and interact with its environment, use the `docker exec` command. For example, to open a shell inside the container:

```bash
docker exec -it mycontainer bash
```

- `-it`: Combines the `-i` (interactive) and `-t` (allocate a terminal) flags to allow for interactive use.
- `bash`: Starts the `bash` shell inside the container (you can use other shells like `sh` depending on the container).

This command opens an interactive terminal session inside the container, where you can run commands directly.

#### 7. **Viewing Container Logs**

To view the logs of a running or stopped container, use the `docker logs` command:

```bash
docker logs mycontainer
```

This will display the logs generated by the container, which can be useful for debugging.

#### 8. **Restarting a Container**

You can restart a container using the `docker restart` command:

```bash
docker restart mycontainer
```

This stops and then immediately restarts the container.

#### 9. **Viewing Container Resource Usage**

To view the resource usage of running containers (such as CPU and memory usage), use:

```bash
docker stats
```

This will display real-time statistics for all running containers.

---

### Docker Container Networking

Docker containers are isolated from each other and from the host machine by default, but they can communicate with each other through Docker's networking features. When you run a container, Docker assigns it a default network (usually a bridge network).

Here are some common networking options:

1. **Bridge Network** (default): Containers on the same bridge network can communicate with each other via their IP addresses.
2. **Host Network**: The container shares the network namespace with the host. This can be useful when you need a container to directly access host resources.
3. **Overlay Network**: Used for multi-host networking. It enables containers running on different Docker hosts to communicate with each other.
4. **None Network**: Disables networking for a container, isolating it from the network.

To connect a container to a specific network, use the `--network` flag when running a container:

```bash
docker run --network mynetwork mycontainer
```

---

### Docker Volumes and Persisting Data

By default, containers have ephemeral storage, which means that when a container is removed, its data is also lost. To persist data beyond the container's lifecycle, Docker provides **volumes**.

#### 1. **Creating a Volume**

To create a volume:

```bash
docker volume create myvolume
```

#### 2. **Mounting a Volume**

To mount a volume into a container, use the `-v` or `--mount` option with the `docker run` command:

```bash
docker run -v myvolume:/data mycontainer
```

This mounts the `myvolume` volume to the `/data` directory inside the container. Any data written to `/data` will persist even after the container is removed.

---

### Docker Container Lifecycle Example

Here’s an example of how to use Docker containers in practice:

1. **Run a container** with the official Nginx image:

   ```bash
   docker run -d -p 8080:80 --name mynginx nginx
   ```

2. **List containers**:

   ```bash
   docker ps
   ```

3. **Stop the container**:

   ```bash
   docker stop mynginx
   ```

4. **Remove the container**:

   ```bash
   docker rm mynginx
   ```

5. **Run the container again**, this time with a volume mounted:

   ```bash
   docker run -d -p 8080:80 -v myvolume:/usr/share/nginx/html --name mynginx nginx
   ```

---

### Conclusion

Docker containers are a core concept in containerization, providing a lightweight and portable way to package and run applications. They offer isolation, portability, and efficiency compared to traditional virtual machines. With containers, you can ensure that your applications run consistently across different environments, from development to production. Docker makes it easy to create, manage, and orchestrate containers, enabling modern, microservice-based architectures.
